grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/example/mydsl/MyDsl"

Model:
	greetings+=Greeting*;
	
Greeting:
	SourceFile;

terminal NEWLINE:
	"\n" | "\r" | "\n\r"
;


terminal LETTER:
	"a".."z" | "A" .."Z"| "_" 
;

terminal DECIMAL_DIGIT:
	"0".. "9"
;

terminal OCTAL_DIGIT:
	"0" .. "7"
;

terminal HEX_DIGIT:
	"0" .. "9" | "A" .. "F" | "a" .. "f"
;

terminal BREAK:
	"break"
;
terminal DEFAULT:
	"default"
;
terminal FUNC:
	"func"
;
terminal INTERFACE:
	"interface"
;
terminal SELECT:
	"select"
;
terminal CASE:
	"case"
;
terminal DEFER:
	"defer"
;
terminal GO:
	"go"
;
terminal MAP:
	"map"
;
terminal STRUCT:
	"struct"
;
terminal CHAN:
	"chan"
;
terminal ELSE:
	"else"
;
terminal GOTO:
	"goto"
;
terminal PACKAGE:
	"package"
;
terminal SWITCH:
	"switch"
;
terminal CONST:
	"const"
;
terminal FALLTHROUGH:
	"fallthrough"
;
terminal IF:
	"if"
;
terminal RANGE:
	"range"
;
terminal TYPEKEYWORD:
	"type"
;
terminal CONTINUE:
	"continue"
;
terminal FOR:
	"for"
;
terminal IMPORT:
	"import"
;
terminal RETURN: 
	"return"
;
terminal VAR: 
	"var"
;
terminal IDENTIFIER:
	LETTER ( LETTER | ("0".."9") )*
;

terminal UNICODE_CHAR:
	"fazeer"
;

terminal INT_LIT:
	( ('1'..'9') DECIMAL_DIGIT*)
	| "0" (OCTAL_DIGIT)*
    | ( '0' ('x'|"X") HEX_DIGIT+)
;

FLOAT_LIT:
	DECIMALS FLOAT_LIT_Linha
	|DECIMALS '.' (DECIMALS) FLOAT_LIT_Linha_Linha
	|DECIMALS '.' FLOAT_LIT_Linha_Linha_Linha
	| '.' DECIMALS  (EXPONENT)
;

FLOAT_LIT_Linha_Linha_Linha:
	(EXPONENT) | ANY_OTHER
;

FLOAT_LIT_Linha_Linha:
	(EXPONENT) | ANY_OTHER
;

FLOAT_LIT_Linha:
	 (EXPONENT) | ANY_OTHER 
;

terminal DECIMALS:
     INT
;

terminal EXPONENT:
    ("e"|"E")('+'|'-')? DECIMALS
;

IMAGINARY_LIT:
	(DECIMALS | FLOAT_LIT) "i" 
;

terminal RUNE_LIT:
	 "'" ( UNICODE_VALUE | BYTE_VALUE ) "'" ;

terminal UNICODE_VALUE:
	UNICODE_CHAR | LITTLE_U_VALUE | BIG_U_VALUE | ESCAPED_CHAR
;

terminal BYTE_VALUE:
	OCTAL_BYTE_VALUE | HEX_BYTE_VALUE
;

terminal OCTAL_BYTE_VALUE:
	'\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT
;

terminal HEX_BYTE_VALUE:
	'\\' "x" HEX_DIGIT HEX_DIGIT
;
terminal LITTLE_U_VALUE:
	'\\' "u" HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
;
terminal BIG_U_VALUE:
	'\\' "U" HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
	
;
terminal ESCAPED_CHAR:
	  '\\' ("a" | "b" | "f" | "n" | "r" | "t" | "v"  | '\\' | "'" | '"')
;

terminal STRING_LIT:
	RAW_STRING_LIT | INTERPRETED_STRING_LIT
;

terminal RAW_STRING_LIT:
	"'" ( UNICODE_CHAR | NEWLINE )* "'"
;

terminal INTERPRETED_STRING_LIT:
	'"' (UNICODE_VALUE | BYTE_VALUE)* '"'
;

Type: 
	TypeName | TypeLit | "(" Type ")"
;

TypeName: 
	IDENTIFIER TypeNameLinha
;

TypeNameLinha:
	"." IDENTIFIER |  ANY_OTHER
;

/*QualifiedIdent: 
	PackageName "." IDENTIFIER
;*/

PackageName: 
	IDENTIFIER
;

TypeLit: 
	 "[" TypeLitLinha | StructType | PointerType | FunctionType | InterfaceType |
	  MapType | ChannelType
;

TypeLitLinha:
	ArrayLength "]" ElementType 
	| "]" ElementType
;

ArrayLength: 
	Expression
;

ElementType: 
	Type
;

StructType: 
	STRUCT "{"  (FieldDecl ";")* "}"
;

FieldDecl: //ve
	(IdentifierList Type | EmbeddedField) (Tag)?
;

EmbeddedField: 
	("*")? TypeName
;

Tag: 
	STRING_LIT
;

PointerType:
	"*" BaseType
;

BaseType:
	Type
;

FunctionType: 
	FUNC Signature
;

Signature: 
	(Parameters)(=>Result)?
;

Result: 
	(=>Parameters) | Type
;
Parameters:
	"(" (ParameterList (",")?)? ")"
;

ParameterList:
	ParameterDecl ("," ParameterDecl)*
;

ParameterDecl:
	(IdentifierList)? ("...")? Type
;

InterfaceType: 
	INTERFACE "{" (MethodSpec ";") "}"
;

MethodSpec: 
	MethodName Signature | InterfaceTypeName
;

MethodName: 
	IDENTIFIER
;

InterfaceTypeName: 
	TypeName
;

MapType:
	MAP "[" KeyType "]" ElementType
;

KeyType:
	Type
;

ChannelType: 
	( CHAN ChannelTypeLinha | "<-" CHAN) ElementType
;

ChannelTypeLinha://fatoracao
	"<-" | ANY_OTHER
;

Expression: 
	UnaryExpr Expression_Linha
;

Expression_Linha: 
	binary_op Expression Expression_Linha | ANY_OTHER
;

UnaryExpr: 
	PrimaryExpr | UNARY_OP UnaryExpr
;

binary_op: 
	"||" | "&&" | REL_OP | ADD_OP | MUL_OP
;

terminal REL_OP : 
	"==" | "!=" | "<" | "<=" | ">" | ">="
;
terminal ADD_OP :
	"+" | "-" | "|" | "^" 
;
terminal MUL_OP :
	"*" | "/" | "%" | "<<" | ">>" | "&" | "&^"
;
terminal UNARY_OP: 
	"+" | "-" | "!" | "^" | "*" | "&" | "<-" 
;

PrimaryExpr: 
	BasicLit PrimaryExprLinha
	|StructType PrimaryExprFatFatFatFat
	|MapType PrimaryExprFatFatFatFat
	| FUNC Signature PrimaryExprFatFatFatFatFat PrimaryExprLinha
	| "..." "]" ElementType LiteralValue PrimaryExprLinha
	|  Name PrimaryExprFatFatFat PrimaryExprLinha
	| "("  PrimaryExprFatFat PrimaryExprLinha  
	| "[" TypeLitLinha PrimaryExprFatFatFatFatFatFat PrimaryExprLinha
	|PointerType PrimaryExprFat PrimaryExprLinha
	| InterfaceType PrimaryExprFat PrimaryExprLinha
	|ChannelType PrimaryExprFat PrimaryExprLinha
	
	//(Literal | OperandName | "(" Expression ")") PrimaryExprLinha 
	//| (TypeName | TypeLit ) PrimaryExprFat PrimaryExprLinha
;

PrimaryExprFatFatFatFatFatFat:
	LiteralValue | PrimaryExprFat
;
PrimaryExprFatFatFatFatFat:
	FunctionBody | PrimaryExprFat
;
PrimaryExprFatFatFatFat:
	LiteralValue | PrimaryExprFat
;
PrimaryExprFatFatFat:
	LiteralValue | PrimaryExprFat | ANY_OTHER
;


Name:
	IDENTIFIER NameLinha
;

NameLinha:
	"." IDENTIFIER | ANY_OTHER
;
PrimaryExprFatFat:
	(=>Expression ")") | Type ")" PrimaryExprFat
;
PrimaryExprFat:
	"(" Expression ( "," )? ")" | "." MethodName
;

PrimaryExprLinha:
	"." PrimaryExprLinhaLinha PrimaryExprLinha
	| "[" PrimaryExprLinhaLinhaLinha PrimaryExprLinha
	| Arguments PrimaryExprLinha
;

PrimaryExprLinhaLinha:
	IDENTIFIER | "(" Type ")"
;

PrimaryExprLinhaLinhaLinha:
	Expression PrimaryExprLinhaLinhaLinhaLinha |  ":" SliceLinha
;

PrimaryExprLinhaLinhaLinhaLinha:
	"]" | ":" SliceLinha
;

/*Selector: 
	"." IDENTIFIER
;*/

/*Index:
	"[" Expression "]"
;*/

/*Slice:
	"[" (Expression)? ":" SliceLinha
;*/

SliceLinha: //fatoracao
	":" (Expression)? "]" | Expression ":" Expression "]";

/*TypeAssertion:
	"." "(" Type ")"
;*/

Arguments:
	"(" ( ( (=>ExpressionList) | Type ("," ExpressionList)? ) ( "...")? ( "," )?)? ")"
;

ExpressionList: 
	Expression ("," Expression)*
;

IdentifierList: 
	IDENTIFIER( "," IDENTIFIER )*
;

Block: 
	"{" StatementList "}"
;

StatementList: 
	( Statement ";")*
;

Statement:
	Declaration | LabeledStmt | SimpleStmt |
	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
	DeferStmt
;

DeferStmt:
	DEFER Expression	
;

ForStmt:
	 FOR ( Expression ForStmtLinha)? Block
;

ForStmtLinha://fatoracao
	(SimpleStmtLinha| (IDENTIFIER( "," IDENTIFIER )*) ":=" (Expression ("," Expression)*) ) ";" ( Condition ) ";" ( Expression SimpleStmtLinha| (IDENTIFIER( "," IDENTIFIER )*) ":=" (Expression ("," Expression)*) 
		|(("," Expression)*) "=" | IdentifierList ":=" ) RANGE Expression 
		|ANY_OTHER
;

/*RangeClause:
	( ExpressionList "=" | IdentifierList ":=" ) "range" Expression
;

ForClause:
	( InitStmt ) ";" ( Condition ) ";" ( PostStmt )
;

PostStmt:
	SimpleStmt
;

InitStmt:
	SimpleStmt
;*/

Condition:
	Expression
;

SelectStmt:
	SELECT "{" ( CommClause )* "}"
;

CommClause:
	CommCase ":" StatementList
;

CommCase:
	CASE ( Expression CommCaseLinha) | DEFAULT
;

CommCaseLinha:
	"<-" Expression | (("," Expression)* "=" | IdentifierList ":=" ) RecvExpr
;

/*RecvStmt:
	( ExpressionList "=" | IdentifierList ":=" ) RecvExpr
;*/

RecvExpr:
	Expression
;

SwitchStmt:
	SWITCH ( SimpleStmt ";" ) SwitchStmtLinha
;

SwitchStmtLinha://fatoracao
	( Expression ) "{" ( ExprCaseClause )* "}" | TypeSwitchGuard "{" ( TypeCaseClause )* "}"
;


/*TypeSwitchStmt:
	"switch" ( SimpleStmt ";" ) TypeSwitchGuard "{" ( TypeCaseClause )* "}"	
;*/

TypeCaseClause:
	TypeSwitchCase ":" StatementList
;

TypeSwitchCase:
	CASE TypeList | DEFAULT	
;

TypeList:
	Type ( "," Type )*
;

TypeSwitchGuard:
	( IDENTIFIER ":=" ) PrimaryExpr "." "(" TYPEKEYWORD ")"
;

/*ExprSwitchStmt:
	"switch" ( SimpleStmt ";" ) ( Expression ) "{" ( ExprCaseClause )* "}"
;*/

ExprCaseClause:
	ExprSwitchCase ":" StatementList
;

ExprSwitchCase:
	CASE ExpressionList | DEFAULT
;

IfStmt:
	IF ( 
		SimpleStmt ";"
	) Expression Block ( ELSE ( IfStmt | Block ) )
;

FallthroughStmt:
	FALLTHROUGH
;

GotoStmt:
	GOTO Label
;

ContinueStmt:
	CONTINUE ( Label )
;

BreakStmt:
	BREAK ( Label )
;

ReturnStmt:
	RETURN ( ExpressionList )
;

GoStmt:
	GO Label
;

SimpleStmt:
	Expression SimpleStmtLinha| (IDENTIFIER( "," IDENTIFIER )*) ":=" (Expression ("," Expression)*)
;

SimpleStmtLinha:
	"<-" Expression  | ( "++" | "--" ) | ("," Expression)* assign_op (Expression ("," Expression)*)
;

/*Assignment:
	ExpressionList assign_op ExpressionList
;*/

assign_op:
	( ADD_OP | MUL_OP ) "="
;

/*IncDecStmt:
	Expression ( "++" | "--" )
;

SendStmt:
	Channel "<-" Expression 
;

Channel:
	Expression
;*/

/*ExpressionStmt:
	Expression
;*/

LabeledStmt:
	Label ":" Statement 
;

Label:
	IDENTIFIER
;

Declaration: 
	ConstDecl | TypeDecl | VarDecl
;

TopLevelDecl: 
	Declaration | FunctionDecl | MethodDecl
;

ConstDecl: 
	CONST ( ConstSpec | "(" (ConstSpec ";")* ")" )
;

ConstSpec: 
	IdentifierList ((Type)? "=" ExpressionList)?
;

TypeDecl: 
	TYPEKEYWORD ( TypeSpec | "(" (TypeSpec ";")* ")" )
;

TypeSpec: 
	AliasDecl | TypeDef
;

AliasDecl: 
	IDENTIFIER "=" Type
;

TypeDef: 
	IDENTIFIER Type
;

VarDecl: 
	VAR ( VarSpec | "(" (VarSpec ";")* ")" )
;

VarSpec: 
	IdentifierList ( Type ( "=" ExpressionList)? | "=" ExpressionList )
;

/*ShortVarDecl: 
	IdentifierList ":=" ExpressionList
;*/

FunctionDecl:
	FUNC FunctionName Signature (FunctionBody)?
;

FunctionName: 
	IDENTIFIER
;

FunctionBody: 
	Block
;

MethodDecl: 
	FUNC Receiver MethodName Signature (FunctionBody)?
;

Receiver: 
	Parameters
;

/*Operand: 
	Literal | OperandName | "(" Expression ")"
;

Literal: 
	BasicLit | CompositeLit | FunctionLit
;*/

BasicLit:
	   INT_LIT | STRING_LIT | FLOAT_LIT | IMAGINARY_LIT
;

/*OperandName: 
	IDENTIFIER OperandNameLinha
;

OperandNameLinha:
	"." IDENTIFIER | ANY_OTHER
;


CompositeLit: 
	LiteralType LiteralValue
;

LiteralType: 
	StructType | MapType | TypeName | "[" LiteralTypeLinha
;

LiteralTypeLinha://fatoracao
	(=>ArrayLength "]" ElementType) | "..." "]" ElementType | "]" ElementType
;*/

LiteralValue: 
	"{" ( ElementList ( "," )? )? "}"
;

ElementList: 
	KeyedElement ( "," KeyedElement)*
;

KeyedElement: 
	(=>( Key ":")?) Element
;

Key: 
	FieldName | Expression | LiteralValue
;

FieldName: 
	IDENTIFIER
;

Element: 
	Expression | LiteralValue
;


/*FunctionLit: 
	"func" Signature FunctionBody
;

MethodExpr: 
	ReceiverType "." MethodName
;

ReceiverType:
	Type
;

Conversion: 
	Type "(" Expression ( "," )? ")"
;*/

SourceFile: 
	PackageClause ";" ( ImportDecl ";" )* ( TopLevelDecl ";" )*
;

PackageClause: 
	PACKAGE PackageName
;

ImportDecl:
	IMPORT ( ImportSpec | "(" ( ImportSpec ";" )* ")" )
;

ImportSpec:
	( "." | PackageName )? ImportPath
;

ImportPath: 
	STRING_LIT
;

	
