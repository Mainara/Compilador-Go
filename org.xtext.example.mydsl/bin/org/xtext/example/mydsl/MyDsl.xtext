grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/example/mydsl/MyDsl"

Model:
	greetings+=Greeting*;
	
Greeting:
	SourceFile;

terminal LETTER:
	"a".."z" | "A" .."Z"| "_" 
;

terminal NEW_LINE:
	"\n" | "\r" | "\n\r"
;

terminal UNICODE_CHAR:
	(!NEW_LINE)
;

terminal INT_LITERAL:
	( '1'..'9' ( '0'..'9' )* )
    | ( '0'..'7' )*
    | ( '0' ('x'|"X") ('0'..'9'|'a'..'f'|"A".."F")+ )
;

float_literal:
    (
            ( DECIMAL_DIGITS  '.'  ( DECIMAL_DIGITS ) ( EXPONENT_PART )   )
            | (  '.' DECIMAL_DIGITS  ( EXPONENT_PART )    )
            | ( DECIMAL_DIGITS  ( EXPONENT_PART )   )
    )
;


terminal DECIMAL_DIGITS:
    '0'..'9'  ('0'..'9')*
;

terminal EXPONENT_PART:
    'e'  ( '+'|'-') DECIMAL_DIGITS
;

Imaginary_lit:
	(DECIMAL_DIGITS | float_literal) "i" 
;

terminal STRING_LIT:
	"oi"//ajeitar
;

terminal RUNE_LIT:
	"oiiii"//ve o que e unicode_char
;

Type: 
	TypeName | TypeLit | "(" Type ")"
;

TypeName: 
	IDENTIFIER TypeNameLinha
;

TypeNameLinha:
	"." IDENTIFIER |  ANY_OTHER
;

QualifiedIdent: 
	PackageName "." IDENTIFIER
;

PackageName: 
	IDENTIFIER
;

TypeLit: 
	 "[" TypeLitLinha | StructType | PointerType | FunctionType | InterfaceType |
	  MapType | ChannelType
;

TypeLitLinha:
	ArrayLength "]" ElementType 
	| "]" ElementType
;

ArrayLength: 
	Expression
;

ElementType: 
	Type
;

StructType: 
	"struct" "{"  (FieldDecl ";")* "}"
;

FieldDecl: //ve
	(IdentifierList Type | EmbeddedField) (Tag)?
;

EmbeddedField: 
	("*")? TypeName
;

Tag: 
	STRING_LIT
;

PointerType:
	"*" BaseType
;

BaseType:
	Type
;

FunctionType: 
	"func" Signature
;

Signature: 
	(Parameters)(=>Result)?
;

Result: 
	(=>Parameters) | Type
;
Parameters:
	"(" (ParameterList (",")?)? ")"
;

ParameterList:
	ParameterDecl ("," ParameterDecl)*
;

ParameterDecl:
	(IdentifierList)? ("...")? Type
;

InterfaceType: 
	"interface" "{" (MethodSpec ";") "}"
;

MethodSpec: 
	MethodName Signature | InterfaceTypeName
;

MethodName: 
	IDENTIFIER
;

InterfaceTypeName: 
	TypeName
;

MapType:
	"map" "[" KeyType "]" ElementType
;

KeyType:
	Type
;

ChannelType: 
	( "chan" ChannelTypeLinha | "<-" "chan") ElementType
;

ChannelTypeLinha://fatoracao
	"<-" | ANY_OTHER
;

Expression: 
	UnaryExpr Expression_Linha
;

Expression_Linha: 
	binary_op Expression Expression_Linha
;

UnaryExpr: 
	PrimaryExpr | UNARY_OP UnaryExpr
;

binary_op: 
	"||" | "&&" | REL_OP | ADD_OP | MUL_OP
;

terminal REL_OP : 
	"==" | "!=" | "<" | "<=" | ">" | ">="
;
terminal ADD_OP :
	"+" | "-" | "|" | "^" 
;
terminal MUL_OP :
	"*" | "/" | "%" | "<<" | ">>" | "&" | "&^"
;
terminal UNARY_OP: 
	"+" | "-" | "!" | "^" | "*" | "&" | "<-" 
;

PrimaryExpr: 
	BasicLit PrimaryExprLinha
	|StructType PrimaryExprFatFatFatFat
	|MapType PrimaryExprFatFatFatFat
	| "func" Signature PrimaryExprFatFatFatFatFat PrimaryExprLinha
	| "..." "]" ElementType LiteralValue PrimaryExprLinha
	|  Name PrimaryExprFatFatFat PrimaryExprLinha
	| "("  PrimaryExprFatFat PrimaryExprLinha  
	| "[" TypeLitLinha PrimaryExprFatFatFatFatFatFat PrimaryExprLinha
	|PointerType PrimaryExprFat PrimaryExprLinha
	| InterfaceType PrimaryExprFat PrimaryExprLinha
	|ChannelType PrimaryExprFat PrimaryExprLinha
	
	//(Literal | OperandName | "(" Expression ")") PrimaryExprLinha 
	//| (TypeName | TypeLit ) PrimaryExprFat PrimaryExprLinha
;

PrimaryExprFatFatFatFatFatFat:
	LiteralValue | PrimaryExprFat
;
PrimaryExprFatFatFatFatFat:
	FunctionBody | PrimaryExprFat
;
PrimaryExprFatFatFatFat:
	LiteralValue | PrimaryExprFat
;
PrimaryExprFatFatFat:
	LiteralValue | PrimaryExprFat | ANY_OTHER
;


Name:
	IDENTIFIER NameLinha
;

NameLinha:
	"." IDENTIFIER | ANY_OTHER
;
PrimaryExprFatFat:
	(=>Expression ")") | Type ")" PrimaryExprFat
;
PrimaryExprFat:
	"(" Expression ( "," )? ")" | "." MethodName
;

PrimaryExprLinha:
	"." PrimaryExprLinhaLinha PrimaryExprLinha
	| "[" PrimaryExprLinhaLinhaLinha PrimaryExprLinha
	| Arguments PrimaryExprLinha
;

PrimaryExprLinhaLinha:
	IDENTIFIER | "(" Type ")"
;

PrimaryExprLinhaLinhaLinha:
	Expression PrimaryExprLinhaLinhaLinhaLinha |  ":" SliceLinha
;

PrimaryExprLinhaLinhaLinhaLinha:
	"]" | ":" SliceLinha
;

Selector: 
	"." IDENTIFIER
;

Index:
	"[" Expression "]"
;

Slice:
	"[" (Expression)? ":" SliceLinha
;

SliceLinha: //fatoracao
	":" (Expression)? "]" | Expression ":" Expression "]";

TypeAssertion:
	"." "(" Type ")"
;

Arguments:
	"(" ( ( (=>ExpressionList) | Type ("," ExpressionList)? ) ( "...")? ( "," )?)? ")"
;

ExpressionList: 
	Expression ("," Expression)*
;

IdentifierList: 
	IDENTIFIER( "," IDENTIFIER )*
;

Block: 
	"{" StatementList "}"
;

StatementList: 
	( Statement ";")*
;

Statement:
	Declaration | LabeledStmt | SimpleStmt |
	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
	DeferStmt
;

DeferStmt:
	"defer" Expression	
;

ForStmt:
	 "for" ( Expression ForStmtLinha)? Block
;

ForStmtLinha://fatoracao
	(SimpleStmtLinha| (IDENTIFIER( "," IDENTIFIER )*) ":=" (Expression ("," Expression)*) ) ";" ( Condition ) ";" ( Expression SimpleStmtLinha| (IDENTIFIER( "," IDENTIFIER )*) ":=" (Expression ("," Expression)*) 
		|(("," Expression)*) "=" | IdentifierList ":=" ) "range" Expression 
		|ANY_OTHER
;

RangeClause:
	( ExpressionList "=" | IdentifierList ":=" ) "range" Expression
;

ForClause:
	( InitStmt ) ";" ( Condition ) ";" ( PostStmt )
;

PostStmt:
	SimpleStmt
;

InitStmt:
	SimpleStmt
;

Condition:
	Expression
;

SelectStmt:
	"select" "{" ( CommClause )* "}"
;

CommClause:
	CommCase ":" StatementList
;

CommCase:
	"case" ( Expression CommCaseLinha) | "default"
;

CommCaseLinha:
	"<-" Expression | (("," Expression)* "=" | IdentifierList ":=" ) RecvExpr
;

RecvStmt:
	( ExpressionList "=" | IdentifierList ":=" ) RecvExpr
;

RecvExpr:
	Expression
;

SwitchStmt:
	"switch" ( SimpleStmt ";" ) SwitchStmtLinha
;

SwitchStmtLinha://fatoracao
	( Expression ) "{" ( ExprCaseClause )* "}" | TypeSwitchGuard "{" ( TypeCaseClause )* "}"
;


TypeSwitchStmt:
	"switch" ( SimpleStmt ";" ) TypeSwitchGuard "{" ( TypeCaseClause )* "}"	
;

TypeCaseClause:
	TypeSwitchCase ":" StatementList
;

TypeSwitchCase:
	"case" TypeList | "default"	
;

TypeList:
	Type ( "," Type )*
;

TypeSwitchGuard:
	( IDENTIFIER ":=" ) PrimaryExpr "." "(" "type" ")"
;

ExprSwitchStmt:
	"switch" ( SimpleStmt ";" ) ( Expression ) "{" ( ExprCaseClause )* "}"
;

ExprCaseClause:
	ExprSwitchCase ":" StatementList
;

ExprSwitchCase:
	"case" ExpressionList | "default"
;

IfStmt:
	"if" ( 
		SimpleStmt ";"
	) Expression Block ( "else" ( IfStmt | Block ) )
;

FallthroughStmt:
	"fallthrough"
;

GotoStmt:
	"goto" Label
;

ContinueStmt:
	"continue" ( Label )
;

BreakStmt:
	"break" ( Label )
;

ReturnStmt:
	"return" ( ExpressionList )
;

GoStmt:
	"go" Label
;

SimpleStmt:
	Expression SimpleStmtLinha| (IDENTIFIER( "," IDENTIFIER )*) ":=" (Expression ("," Expression)*)
;

SimpleStmtLinha:
	"<-" Expression  | ( "++" | "--" ) | ("," Expression)* assign_op (Expression ("," Expression)*)
;

Assignment:
	ExpressionList assign_op ExpressionList
;

assign_op:
	( ADD_OP | MUL_OP ) "="
;

IncDecStmt:
	Expression ( "++" | "--" )
;

SendStmt:
	Channel "<-" Expression 
;

Channel:
	Expression
;

ExpressionStmt:
	Expression
;

LabeledStmt:
	Label ":" Statement 
;

Label:
	IDENTIFIER
;

Declaration: 
	ConstDecl | TypeDecl | VarDecl
;

TopLevelDecl: 
	Declaration | FunctionDecl | MethodDecl
;

ConstDecl: 
	"const" ( ConstSpec | "(" (ConstSpec ";")* ")" )
;

ConstSpec: 
	IdentifierList ((Type)? "=" ExpressionList)?
;

TypeDecl: 
	"type" ( TypeSpec | "(" (TypeSpec ";")* ")" )
;

TypeSpec: 
	AliasDecl | TypeDef
;

AliasDecl: 
	IDENTIFIER "=" Type
;

TypeDef: 
	IDENTIFIER Type
;

VarDecl: 
	"var" ( VarSpec | "(" (VarSpec ";")* ")" )
;

VarSpec: 
	IdentifierList ( Type ( "=" ExpressionList)? | "=" ExpressionList )
;

ShortVarDecl: 
	IdentifierList ":=" ExpressionList
;

FunctionDecl:
	"func" FunctionName Signature (FunctionBody)?
;

FunctionName: 
	IDENTIFIER
;

FunctionBody: 
	Block
;

MethodDecl: 
	"func" Receiver MethodName Signature (FunctionBody)?
;

Receiver: 
	Parameters
;

Operand: 
	Literal | OperandName | "(" Expression ")"
;

Literal: 
	BasicLit | CompositeLit | FunctionLit
;

BasicLit:
	INT_LITERAL  | STRING_LIT | float_literal | Imaginary_lit
;

OperandName: 
	IDENTIFIER OperandNameLinha
;

OperandNameLinha:
	"." IDENTIFIER | ANY_OTHER
;


CompositeLit: 
	LiteralType LiteralValue
;

LiteralType: 
	StructType | MapType | TypeName | "[" LiteralTypeLinha
;

LiteralTypeLinha://fatoracao
	(=>ArrayLength "]" ElementType) | "..." "]" ElementType | "]" ElementType
;

LiteralValue: 
	"{" ( ElementList ( "," )? )? "}"
;

ElementList: 
	KeyedElement ( "," KeyedElement)*
;

KeyedElement: 
	(=>( Key ":")?) Element
;

Key: 
	FieldName | Expression | LiteralValue
;

FieldName: 
	IDENTIFIER
;

Element: 
	Expression | LiteralValue
;


FunctionLit: 
	"func" Signature FunctionBody
;

MethodExpr: 
	ReceiverType "." MethodName
;

ReceiverType:
	Type
;

Conversion: 
	Type "(" Expression ( "," )? ")"
;

SourceFile: 
	PackageClause ";" ( ImportDecl ";" )* ( TopLevelDecl ";" )*
;

PackageClause: 
	"package" PackageName
;

ImportDecl:
	"import" ( ImportSpec | "(" ( ImportSpec ";" )* ")" )
;

ImportSpec:
	( "." | PackageName )? ImportPath
;

ImportPath: 
	STRING_LIT
;

terminal IDENTIFIER:
	LETTER ( LETTER | ("0".."9") )*
;

	
