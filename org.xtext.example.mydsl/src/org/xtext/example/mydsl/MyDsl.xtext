grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

generate myDsl "http://www.xtext.org/example/mydsl/MyDsl"

Model:
	greetings+=Greeting*;
	
Greeting:
	SourceFile;

terminal UNICODE_LETTER:
	"a".."z" | "A" .."Z"	
;

terminal LETTER:
	UNICODE_LETTER | "_" 
;


terminal INT_LITERAL:
	(
            ( '1'..'9' ( '0'..'9' )* )
            | ( '0'..'7' )*
            | ( '0' ('x'|"X") ('0'..'9'|'a'..'f'|"A".."F")+ )
    )
;


terminal DECIMAL_DIGITS:
    '0'..'9'  ( '0'..'9'  )*
;

terminal EXPONENT_PART:
    'e'  (  '+'  |  '-'  ) DECIMAL_DIGITS
;

terminal STRING_LIT:
	"oi"//ajeitar
;

terminal RUNE_LIT:
	"oiiii"
;

Type: 
	TypeName | TypeLit | "(" Type ")"
;

TypeName: 
	IDENTIFIER TypeNameLinha
;

TypeNameLinha:
	"." IDENTIFIER |  ANY_OTHER
;

QualifiedIdent: 
	PackageName "." IDENTIFIER
;

PackageName: 
	IDENTIFIER
;
TypeLit: 
	ArrayType | StructType | PointerType | FunctionType | InterfaceType |
	    SliceType | MapType | ChannelType 
;

ArrayType: 
	"[" ArrayLength "]" ElementType 
;
ArrayLength: 
	Expression
;

ElementType: 
	Type
;

SliceType: 
	"[" "]" ElementType
;

StructType: 
	"struct" "{"  (FieldDecl ";")* "}"
;

FieldDecl: 
	(IdentifierList Type | EmbeddedField) (Tag)?
;

EmbeddedField: 
	("*")? TypeName
;

Tag: 
	STRING_LIT
;

PointerType:
	"*" BaseType
;

BaseType:
	Type
;

FunctionType: 
	"func" Signature
;

Signature: 
	Parameters(Result)?
;

Result: 
	(=>Parameters) | Type
;
Parameters:
	"(" (ParameterList (",")?)? ")"
;

ParameterList:
	ParameterDecl ("," ParameterDecl)*
;

ParameterDecl:
	(IdentifierList)? ("...")? Type
;

InterfaceType: 
	"interface" "{" (MethodSpec ";") "}"
;

MethodSpec: 
	MethodName Signature | InterfaceTypeName
;

MethodName: 
	IDENTIFIER
;

InterfaceTypeName: 
	TypeName
;

MapType:
	"map" "[" KeyType "]" ElementType
;

KeyType:
	Type
;

ChannelType: 
	( "chan" ChannelTypeLinha | "<-" "chan") ElementType
;

ChannelTypeLinha:
	"<-" | ANY_OTHER
;

/*Expression: 
	UnaryExpr | Expression binary_op Expression
;*/

Expression: UnaryExpr Expression_Linha;
Expression_Linha : binary_op Expression_Linha;

UnaryExpr: 
	PrimaryExpr | UNARY_OP UnaryExpr
;
binary_op: 
	"||" | "&&" | REL_OP | ADD_OP | MUL_OP
;

terminal REL_OP : 
	"==" | "!=" | "<" | "<=" | ">" | ">="
;
terminal ADD_OP :
	"+" | "-" | "|" | "^" 
;
terminal MUL_OP :
	"*" | "/" | "%" | "<<" | ">>" | "&" | "&^"
;
terminal UNARY_OP: 
	"+" | "-" | "!" | "^" | "*" | "&" | "<-" 
;

PrimaryExpr: 
	Operand PrimaryExpr_Linha | Type PrimaryExprFatoracao PrimaryExpr_Linha
;

PrimaryExprFatoracao:
	"(" Expression ( "," )? ")" | "." MethodName
;

PrimaryExpr_Linha: "." PrimaryExprFatorado PrimaryExpr_Linha 
					| "["Expression PrimaryExpr_Fatorado1 PrimaryExpr_Linha
					|  "["  ":" SliceLinha
					| Arguments PrimaryExpr_Linha 
					| ANY_OTHER
;

PrimaryExprFatorado : IDENTIFIER | "(" Type ")"	
;

PrimaryExpr_Fatorado1: "]" | ":" SliceLinha ;

Selector: 
	"." IDENTIFIER
;
Index:
	"[" Expression "]"
;
Slice:
	"[" (Expression)? ":" SliceLinha
;

SliceLinha: ":" (Expression)? "]" | Expression ":" Expression "]";

TypeAssertion:
	"." "(" Type ")"
;

Arguments:
	"(" ( ( ExpressionList | Type ("," ExpressionList)? ) ( "...")? ( "," )?)? ")"
;

ExpressionList: 
	Expression ("," Expression)*
;
IdentifierList: 
	IDENTIFIER( "," IDENTIFIER )*
;

Block: 
	"{" StatementList "}"
;

StatementList: 
	( Statement ";")*
;

Statement:
	Declaration | LabeledStmt | SimpleStmt |
	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
	DeferStmt
;

DeferStmt:
	"defer" Expression	
;

ForStmt:
	 "for" ( Expression ForStmtLinha)? Block
;

ForStmtLinha:
	(SimpleStmtLinha| (IDENTIFIER( "," IDENTIFIER )*) ":=" (Expression ("," Expression)*) ) ";" ( Condition ) ";" ( Expression SimpleStmtLinha| (IDENTIFIER( "," IDENTIFIER )*) ":=" (Expression ("," Expression)*) 
		|(("," Expression)*) "=" | IdentifierList ":=" ) "range" Expression 
		|ANY_OTHER
;

RangeClause:
	( ExpressionList "=" | IdentifierList ":=" ) "range" Expression
;

ForClause:
	( InitStmt ) ";" ( Condition ) ";" ( PostStmt )
;

PostStmt:
	SimpleStmt
;

InitStmt:
	SimpleStmt
;

Condition:
	Expression
;

SelectStmt:
	"select" "{" ( CommClause )* "}"
;

CommClause:
	CommCase ":" StatementList
;

CommCase:
	"case" ( Expression CommCaseLinha) | "default"
;

CommCaseLinha:
	"<-" Expression | (("," Expression)* "=" | IdentifierList ":=" ) RecvExpr
;

RecvStmt:
	( ExpressionList "=" | IdentifierList ":=" ) RecvExpr
;

RecvExpr:
	Expression
;

SwitchStmt:
	"switch" ( SimpleStmt ";" ) SwitchStmtLinha
;

SwitchStmtLinha:
	( Expression ) "{" ( ExprCaseClause )* "}" | TypeSwitchGuard "{" ( TypeCaseClause )* "}"
;


TypeSwitchStmt:
	"switch" ( SimpleStmt ";" ) TypeSwitchGuard "{" ( TypeCaseClause )* "}"	
;

TypeCaseClause:
	TypeSwitchCase ":" StatementList
;

TypeSwitchCase:
	"case" TypeList | "default"	
;

TypeList:
	Type ( "," Type )*
;

TypeSwitchGuard:
	( IDENTIFIER ":=" ) PrimaryExpr "." "(" "type" ")"
;

ExprSwitchStmt:
	"switch" ( SimpleStmt ";" ) ( Expression ) "{" ( ExprCaseClause )* "}"
;

ExprCaseClause:
	ExprSwitchCase ":" StatementList
;

ExprSwitchCase:
	"case" ExpressionList | "default"
;

IfStmt:
	"if" ( 
		SimpleStmt ";"
	) Expression Block ( "else" ( IfStmt | Block ) )
;

FallthroughStmt:
	"fallthrough"
;

GotoStmt:
	"goto" Label
;

ContinueStmt:
	"continue" ( Label )
;

BreakStmt:
	"break" ( Label )
;

ReturnStmt:
	"return" ( ExpressionList )
;

GoStmt:
	"go" Label
;

SimpleStmt:
	Expression SimpleStmtLinha| (IDENTIFIER( "," IDENTIFIER )*) ":=" (Expression ("," Expression)*)
;

SimpleStmtLinha:
	"<-" Expression  | ( "++" | "--" ) | ("," Expression)* assign_op (Expression ("," Expression)*)
;

Assignment:
	ExpressionList assign_op ExpressionList
;

assign_op:
	( ADD_OP | MUL_OP ) "="
;

IncDecStmt:
	Expression ( "++" | "--" )
;

SendStmt:
	Channel "<-" Expression 
;

Channel:
	Expression
;

ExpressionStmt:
	Expression
;

LabeledStmt:
	Label ":" Statement 
;

Label:
	IDENTIFIER
;



Declaration: 
	ConstDecl | TypeDecl | VarDecl
;

TopLevelDecl: 
	Declaration | FunctionDecl | MethodDecl
;

ConstDecl: 
	"const" ( ConstSpec | "(" (ConstSpec ";")* ")" )
;

ConstSpec: 
	IdentifierList ((Type)? "=" ExpressionList)?
;

TypeDecl: 
	"type" ( TypeSpec | "(" (TypeSpec ";")* ")" )
;

TypeSpec: 
	AliasDecl | TypeDef
;

AliasDecl: 
	IDENTIFIER "=" Type
;

TypeDef: 
	IDENTIFIER Type
;

VarDecl: 
	"var" ( VarSpec | "(" (VarSpec ";")* ")" )
;
VarSpec: 
	IdentifierList ( Type ( "=" ExpressionList)? | "=" ExpressionList )
;

ShortVarDecl: 
	IdentifierList ":=" ExpressionList
;

FunctionDecl:
	"func" FunctionName Signature (FunctionBody)?
;

FunctionName: 
	IDENTIFIER
;

FunctionBody: 
	Block
;

MethodDecl: 
	"func" Receiver MethodName Signature (FunctionBody)?
;

Receiver: 
	Parameters
;

Operand: 
	Literal | OperandName | "(" Expression ")"
;

Literal: 
	BasicLit | CompositeLit | FunctionLit
;

BasicLit:
	INT_LITERAL  | STRING_LIT | float_literal
;

float_literal:
    (
            ( DECIMAL_DIGITS  '.'  ( DECIMAL_DIGITS ) ( EXPONENT_PART )   )
            | (  '.' DECIMAL_DIGITS  ( EXPONENT_PART )    )
            | ( DECIMAL_DIGITS  ( EXPONENT_PART )   )
    )
;

OperandName: 
	IDENTIFIER OperandNameLinha
;

OperandNameLinha:
	"." IDENTIFIER | ANY_OTHER
;


CompositeLit: 
	LiteralType LiteralValue
;

LiteralType: 
	StructType | ArrayType | "[" "..." "]" ElementType |
                SliceType | MapType | TypeName
;

LiteralValue: 
	"{" ( ElementList ( "," )? )? "}"
;

ElementList: 
	KeyedElement ( "," KeyedElement)*
;

KeyedElement: 
	(=>( Key ":")?) Element
;

Key: 
	FieldName | Expression | LiteralValue
;

FieldName: 
	IDENTIFIER
;

Element: 
	Expression | LiteralValue
;


FunctionLit: 
	"func" Signature FunctionBody
;

MethodExpr: 
	ReceiverType "." MethodName
;
ReceiverType:
	Type
;

Conversion: 
	Type "(" Expression ( "," )? ")"
;

SourceFile: PackageClause ";" ( ImportDecl ";" )* ( TopLevelDecl ";" )*;

PackageClause: "package" PackageName;

ImportDecl:"import" ( ImportSpec | "(" ( ImportSpec ";" )* ")" );
ImportSpec:( "." | PackageName )? ImportPath;
ImportPath: STRING_LIT;

terminal IDENTIFIER:
	LETTER ( LETTER | ("0".."9") )*
;

	
